"use strict";(self.webpackChunkevent_bus_docs=self.webpackChunkevent_bus_docs||[]).push([[377],{5658:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api/strategies/stateful","title":"Stateful Strategy","description":"The StatefulStrategy maintains a history of events and can replay past events to new subscribers. It\'s particularly useful for components that need to initialize their state based on events that occurred before they subscribed.","source":"@site/docs/api/strategies/stateful.md","sourceDirName":"api/strategies","slug":"/api/strategies/stateful","permalink":"/EDA-event-bus/docs/api/strategies/stateful","draft":false,"unlisted":false,"editUrl":"https://github.com/adiyy2001/EDA-event-bus/tree/main/projects/event-bus-docs/docs/api/strategies/stateful.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Stateless Strategy","permalink":"/EDA-event-bus/docs/api/strategies/stateless"},"next":{"title":"Stateless Strategy","permalink":"/EDA-event-bus/docs/api/strategies/debounce"}}');var r=n(4848),i=n(8453);const a={sidebar_position:3},o="Stateful Strategy",l={},c=[{value:"Key Features",id:"key-features",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Usage",id:"usage",level:2},{value:"Working with Event History",id:"working-with-event-history",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Comparison with Other Strategies",id:"comparison-with-other-strategies",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"stateful-strategy",children:"Stateful Strategy"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"StatefulStrategy"})," maintains a history of events and can replay past events to new subscribers. It's particularly useful for components that need to initialize their state based on events that occurred before they subscribed."]}),"\n",(0,r.jsx)(t.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Maintains a complete history of events by event type"}),"\n",(0,r.jsx)(t.li,{children:"Automatically replays past events to new subscribers"}),"\n",(0,r.jsx)(t.li,{children:"Provides methods to retrieve or clear event history"}),"\n",(0,r.jsx)(t.li,{children:"Supports clean-up of specific event types"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(t.p,{children:["Use the ",(0,r.jsx)(t.code,{children:"StatefulStrategy"})," when:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Components need to recover their state after being created or recreated"}),"\n",(0,r.jsx)(t.li,{children:"You need event replay capability for late subscribers"}),"\n",(0,r.jsx)(t.li,{children:"You want to implement event sourcing patterns"}),"\n",(0,r.jsx)(t.li,{children:"You need audit trails or history of specific event types"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"export class StatefulStrategy implements EventBusStrategy {\n  private listeners = new Map<string, Array<(event: BaseEvent) => void>>();\n  private eventHistory = new Map<string, BaseEvent[]>();\n\n  /**\n   * Subscribe to an event type and replay its history.\n   * @param eventType The event type to subscribe to.\n   * @param listener The callback function to invoke when the event is emitted.\n   */\n  subscribe(eventType: string, listener: (event: BaseEvent) => void): void {\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, []);\n    }\n    this.listeners.get(eventType)!.push(listener);\n\n    // Replay event history for the new subscriber\n    const history = this.eventHistory.get(eventType) || [];\n    history.forEach((event) => listener(event));\n  }\n\n  /**\n   * Unsubscribe a listener from an event type.\n   * @param eventType The event type to unsubscribe from.\n   * @param listener The callback function to remove.\n   */\n  unsubscribe(eventType: string, listener: (event: BaseEvent) => void): void {\n    const eventListeners = this.listeners.get(eventType);\n    if (eventListeners) {\n      this.listeners.set(\n        eventType,\n        eventListeners.filter((l) => l !== listener)\n      );\n    }\n  }\n\n  /**\n   * Emit an event and store it in history.\n   * @param eventType The type of event being emitted.\n   * @param event The event object containing data.\n   */\n  emit(eventType: string, event: BaseEvent): void {\n    if (!this.eventHistory.has(eventType)) {\n      this.eventHistory.set(eventType, []);\n    }\n    this.eventHistory.get(eventType)!.push(event);\n\n    const eventListeners = this.listeners.get(eventType);\n    if (eventListeners) {\n      eventListeners.forEach((listener) => listener(event));\n    }\n  }\n\n  /**\n   * Retrieve the history of a specific event type.\n   * @param eventType The event type to retrieve history for.\n   * @returns An array of past events for the given type.\n   */\n  getEventHistory(eventType: string): BaseEvent[] {\n    return this.eventHistory.get(eventType) || [];\n  }\n\n  /**\n   * Clear the history of a specific event type.\n   * @param eventType The event type whose history should be cleared.\n   */\n  clearEventHistory(eventType: string): void {\n    this.eventHistory.delete(eventType);\n  }\n\n  /**\n   * Clean up all listeners and history for an event type.\n   * @param eventType The event type to clean up.\n   */\n  cleanUp(eventType: string): void {\n    this.listeners.delete(eventType);\n    this.eventHistory.delete(eventType);\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { EventBusService, StrategyType, BaseEvent, EventCategory } from '@yourdomain/event-bus-library';\nimport { Subscription } from 'rxjs';\n\ninterface ThemeConfig {\n  primaryColor: string;\n  darkMode: boolean;\n}\n\n@Component({\n  selector: 'app-theme-manager',\n  template: `\n    <div class=\"theme-controls\">\n      <button (click)=\"toggleDarkMode()\">Toggle Dark Mode</button>\n      <input type=\"color\" [(ngModel)]=\"primaryColor\" (change)=\"updatePrimaryColor()\">\n    </div>\n  `\n})\nexport class ThemeManagerComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n  primaryColor: string = '#2196F3';\n  darkMode: boolean = false;\n\n  constructor(private eventBus: EventBusService) {}\n\n  ngOnInit() {\n    // Set the strategy to Stateful to maintain theme state\n    this.eventBus.setStrategy(StrategyType.STATEFUL);\n    \n    // Subscribe to theme changes (will also receive past theme events)\n    this.subscription = this.eventBus.on<ThemeConfig>('theme:changed').subscribe(\n      (event: BaseEvent<ThemeConfig>) => {\n        this.primaryColor = event.payload.primaryColor;\n        this.darkMode = event.payload.darkMode;\n        this.applyTheme(event.payload);\n      }\n    );\n\n    // If this is a fresh launch with no theme history, set default theme\n    const statefulStrategy = this.eventBus['strategy'] as any;\n    if (statefulStrategy.getEventHistory && \n        statefulStrategy.getEventHistory('theme:changed').length === 0) {\n      this.emitThemeChange();\n    }\n  }\n\n  toggleDarkMode() {\n    this.darkMode = !this.darkMode;\n    this.emitThemeChange();\n  }\n\n  updatePrimaryColor() {\n    this.emitThemeChange();\n  }\n\n  private emitThemeChange() {\n    // Emit theme change event\n    this.eventBus.emit<ThemeConfig>({\n      name: 'theme:changed',\n      timestamp: Date.now(),\n      payload: {\n        primaryColor: this.primaryColor,\n        darkMode: this.darkMode\n      },\n      category: EventCategory.USER\n    });\n  }\n\n  private applyTheme(theme: ThemeConfig) {\n    // Apply theme to document\n    document.documentElement.style.setProperty('--primary-color', theme.primaryColor);\n    document.body.classList.toggle('dark-mode', theme.darkMode);\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"working-with-event-history",children:"Working with Event History"}),"\n",(0,r.jsx)(t.p,{children:"You can access the event history directly if you have access to the strategy:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Injectable } from '@angular/core';\nimport { EventBusService, StrategyType, BaseEvent } from '@yourdomain/event-bus-library';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EventHistoryService {\n  constructor(private eventBus: EventBusService) {\n    // Ensure we're using StatefulStrategy\n    this.eventBus.setStrategy(StrategyType.STATEFUL);\n  }\n\n  getEventsOfType<T>(eventType: string): BaseEvent<T>[] {\n    const statefulStrategy = this.eventBus['strategy'] as any;\n    if (statefulStrategy.getEventHistory) {\n      return statefulStrategy.getEventHistory(eventType) as BaseEvent<T>[];\n    }\n    return [];\n  }\n\n  clearEventsOfType(eventType: string): void {\n    const statefulStrategy = this.eventBus['strategy'] as any;\n    if (statefulStrategy.clearEventHistory) {\n      statefulStrategy.clearEventHistory(eventType);\n    }\n  }\n\n  getAllEventTypes(): string[] {\n    const statefulStrategy = this.eventBus['strategy'] as any;\n    if (statefulStrategy.eventHistory instanceof Map) {\n      return Array.from(statefulStrategy.eventHistory.keys());\n    }\n    return [];\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"advantages",children:"Advantages"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"State Recovery"}),": Components can initialize state based on past events"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Late Subscription Support"}),": New subscribers receive past events"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Audit Trail"}),": Provides complete history of events"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Debugging"}),": Easier to debug by examining event history"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Memory Usage"}),": Storing event history can consume significant memory"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance"}),": Replaying large event histories can affect performance"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Storage Type"}),": Events are stored in memory and lost on page refresh"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"comparison-with-other-strategies",children:"Comparison with Other Strategies"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Feature"}),(0,r.jsx)(t.th,{children:"Stateful"}),(0,r.jsx)(t.th,{children:"Stateless"}),(0,r.jsx)(t.th,{children:"Persisted"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Event History"}),(0,r.jsx)(t.td,{children:"Yes, in memory"}),(0,r.jsx)(t.td,{children:"No"}),(0,r.jsx)(t.td,{children:"Yes, in localStorage"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Replay for New Subscribers"}),(0,r.jsx)(t.td,{children:"Yes"}),(0,r.jsx)(t.td,{children:"No"}),(0,r.jsx)(t.td,{children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Memory Usage"}),(0,r.jsx)(t.td,{children:"Higher"}),(0,r.jsx)(t.td,{children:"Lower"}),(0,r.jsx)(t.td,{children:"Medium"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Persistence Across Sessions"}),(0,r.jsx)(t.td,{children:"No"}),(0,r.jsx)(t.td,{children:"No"}),(0,r.jsx)(t.td,{children:"Yes"})]})]})]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);