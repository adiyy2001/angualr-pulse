"use strict";(self.webpackChunkevent_bus_docs=self.webpackChunkevent_bus_docs||[]).push([[424],{8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},9133:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"api/strategies/debounce","title":"Stateless Strategy","description":"The StatelessStrategy is the simplest event bus strategy that implements the basic publish-subscribe pattern. It delivers events to subscribers without maintaining any history or state.","source":"@site/docs/api/strategies/debounce.md","sourceDirName":"api/strategies","slug":"/api/strategies/debounce","permalink":"/EDA-event-bus/docs/api/strategies/debounce","draft":false,"unlisted":false,"editUrl":"https://github.com/adiyy2001/EDA-event-bus/tree/main/projects/event-bus-docs/docs/api/strategies/debounce.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Stateful Strategy","permalink":"/EDA-event-bus/docs/api/strategies/stateful"},"next":{"title":"Logging Middleware","permalink":"/EDA-event-bus/docs/api/middleware/overview"}}');var i=n(4848),r=n(8453);const a={sidebar_position:2},l="Stateless Strategy",d={},o=[{value:"Key Features",id:"key-features",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Usage",id:"usage",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Comparison with Other Strategies",id:"comparison-with-other-strategies",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"stateless-strategy",children:"Stateless Strategy"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StatelessStrategy"})," is the simplest event bus strategy that implements the basic publish-subscribe pattern. It delivers events to subscribers without maintaining any history or state."]}),"\n",(0,i.jsx)(t.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Basic event propagation with no state maintained"}),"\n",(0,i.jsx)(t.li,{children:"Each event is delivered to all subscribers of that specific event type"}),"\n",(0,i.jsx)(t.li,{children:"No event history is kept"}),"\n",(0,i.jsx)(t.li,{children:"New subscribers only receive events emitted after they subscribe"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,i.jsxs)(t.p,{children:["Use the ",(0,i.jsx)(t.code,{children:"StatelessStrategy"})," when:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"You need a simple pub/sub mechanism"}),"\n",(0,i.jsx)(t.li,{children:"Event history is not important"}),"\n",(0,i.jsx)(t.li,{children:"Memory usage should be minimized"}),"\n",(0,i.jsx)(t.li,{children:"You want events to be processed immediately"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"export class StatelessStrategy implements EventBusStrategy {\n  private listeners = new Map<string, Array<(event: BaseEvent) => void>>();\n\n  subscribe(eventType: string, listener: (event: BaseEvent) => void): void {\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, []);\n    }\n    this.listeners.get(eventType)!.push(listener);\n  }\n\n  unsubscribe(eventType: string, listener: (event: BaseEvent) => void): void {\n    const eventListeners = this.listeners.get(eventType);\n    if (eventListeners) {\n      this.listeners.set(\n        eventType,\n        eventListeners.filter((l) => l !== listener)\n      );\n    }\n  }\n\n  emit(eventType: string, event: BaseEvent): void {\n    const eventListeners = this.listeners.get(eventType);\n    if (eventListeners) {\n      eventListeners.forEach((listener) => listener(event));\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { Component, OnInit } from '@angular/core';\nimport { EventBusService, StrategyType, BaseEvent, EventCategory } from '@yourdomain/event-bus-library';\n\ninterface UserData {\n  id: string;\n  name: string;\n}\n\n@Component({\n  selector: 'app-example',\n  template: '<button (click)=\"sendEvent()\">Send Event</button>'\n})\nexport class ExampleComponent implements OnInit {\n  constructor(private eventBus: EventBusService) {}\n\n  ngOnInit() {\n    // Set the strategy to Stateless (this is the default)\n    this.eventBus.setStrategy(StrategyType.STATELESS);\n    \n    // Subscribe to events\n    this.eventBus.on<UserData>('user:updated').subscribe(\n      (event: BaseEvent<UserData>) => {\n        console.log('User updated:', event.payload);\n      }\n    );\n  }\n\n  sendEvent() {\n    // Emit an event\n    this.eventBus.emit<UserData>({\n      name: 'user:updated',\n      timestamp: Date.now(),\n      payload: {\n        id: '123',\n        name: 'John Doe'\n      },\n      category: EventCategory.DOMAIN\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"advantages",children:"Advantages"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Simplicity"}),": Easy to understand and implement"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Low Memory Footprint"}),": Does not store events"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Predictable Behavior"}),": Events are processed in emission order"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"No History"}),": New subscribers miss events emitted before they subscribed"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"No Replay"}),": Cannot replay past events"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"No Batching"}),": Events are processed immediately (which can be inefficient for high-frequency events)"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"comparison-with-other-strategies",children:"Comparison with Other Strategies"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Feature"}),(0,i.jsx)(t.th,{children:"Stateless"}),(0,i.jsx)(t.th,{children:"Stateful"}),(0,i.jsx)(t.th,{children:"Persisted"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Event History"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Replay for New Subscribers"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{children:"No"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Memory Usage"}),(0,i.jsx)(t.td,{children:"Low"}),(0,i.jsx)(t.td,{children:"Higher"}),(0,i.jsx)(t.td,{children:"Medium"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Persistence"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"Yes (localStorage)"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);